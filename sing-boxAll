#!/bin/bash
# =========================================
# Sing-box 全协议节点管理脚本 - 最强伪装 + 配置安全写入终极版（修复续签覆盖/重启）
# 修复点：
# 1) acme.sh --reloadcmd 不传 $1/$2 → HOOK 改为固定路径复制
# 2) 合并为一次 --install-cert（同时指定输出路径 + reloadcmd）
# 3) HOOK 加 set -euo pipefail，复制/重启失败立即报错，不再静默
# 4) 立即覆盖一次并重启 sing-box（首次签发后立刻生效）
# =========================================

set -u

FAKEWEB_DIR="/home/wzweb"
FAKEWEB_PORT=8080

SINGBOX_CONFIG="/etc/sing-box/config.json"
SINGBOX_CONFIG_BAK="/etc/sing-box/config.json.bak"

ACME_HOME="/root/.acme.sh"      # 注意：root 执行时 HOME 才会是 /root；这里写死更稳
CERT_DIR="/root/cert"           # sing-box 实际使用的固定证书路径目录
SINGBOX_SERVICE="/etc/systemd/system/sing-box.service"

MENU_STATUS=("inactive" "inactive" "inactive" "inactive")
DOMAIN=""
TROJAN_PORT=443
TROJAN_PASS=""
HYSTERIA2_PORT=""
HYSTERIA2_PASS=""
TUIC_PORT=""
TUIC_UUID=""
TUIC_PASS=""
HYSTERIA_BANDWIDTH=500

generate_password() { openssl rand -base64 32 | tr -dc 'A-Za-z0-9' | head -c 20; }
generate_uuid() { sing-box generate uuid; }

check_port() {
    local port=$1
    local temp_stop=0

    if systemctl is-active --quiet sing-box && (ss -tuln | grep -q ":$port " || ss -uapn | grep -q ":$port "); then
        systemctl stop sing-box
        temp_stop=1
    fi

    if ss -tuln | grep -q ":$port " || ss -uapn | grep -q ":$port "; then
        [ $temp_stop -eq 1 ] && systemctl start sing-box
        echo "端口 $port 已被占用（TCP 或 UDP），请重新输入。"
        return 1
    else
        [ $temp_stop -eq 1 ] && systemctl start sing-box
        return 0
    fi
}

install_dependencies() {
    echo "安装必要依赖..."
    # 修正：ss 不是 apt 包名；ss 命令来自 iproute2
    # docker-compose 在 Debian/Ubuntu 新版可能是 docker-compose-plugin，但你脚本用 docker-compose，这里尽量兼容两种
    local DEPS=(socat unzip cron dnsutils docker.io openssl curl jq iproute2 tar gzip)

    apt update -y >/dev/null 2>&1 || true
    for pkg in "${DEPS[@]}"; do
        if ! dpkg -s "$pkg" >/dev/null 2>&1; then
            apt install -y "$pkg"
        fi
    done

    # 尝试安装 docker-compose（兼容）
    if ! command -v docker-compose >/dev/null 2>&1; then
        if apt-cache show docker-compose-plugin >/dev/null 2>&1; then
            apt install -y docker-compose-plugin || true
        fi
        if ! command -v docker-compose >/dev/null 2>&1; then
            if apt-cache show docker-compose >/dev/null 2>&1; then
                apt install -y docker-compose || true
            fi
        fi
    fi

    systemctl enable docker >/dev/null 2>&1 || true
    systemctl start docker  >/dev/null 2>&1 || true
}

install_singbox() {
    echo "安装最新版 sing-box..."
    local ARCH
    ARCH=$(uname -m)
    [ "$ARCH" = "x86_64" ] && ARCH="amd64" || ARCH="arm64"

    local LATEST
    LATEST=$(curl -fsSL https://api.github.com/repos/SagerNet/sing-box/releases/latest \
        | grep tag_name | cut -d '"' -f4 | sed 's/v//')

    curl -fsSL "https://github.com/SagerNet/sing-box/releases/download/v${LATEST}/sing-box-${LATEST}-linux-${ARCH}.tar.gz" -o /tmp/sb.tar.gz
    tar -xzf /tmp/sb.tar.gz -C /tmp
    mv "/tmp/sing-box-${LATEST}-linux-${ARCH}/sing-box" /usr/local/bin/
    chmod +x /usr/local/bin/sing-box
    rm -rf /tmp/sb* "/tmp/sing-box-${LATEST}-linux-${ARCH}"
    echo "sing-box 安装完成: v$LATEST"
}

check_singbox() { command -v sing-box >/dev/null 2>&1 || install_singbox; }

check_acme() {
    if [ ! -d "$ACME_HOME" ]; then
        curl -fsSL https://get.acme.sh | sh
    fi
    "$ACME_HOME/acme.sh" --set-default-ca --server letsencrypt
}

deploy_fakeweb() {
    mkdir -p "$FAKEWEB_DIR"
    cd "$FAKEWEB_DIR" || return
    cat > docker-compose.yml <<EOF
version: '3'
services:
  fakeweb:
    image: hongcheng618/wzweb
    ports:
      - "$FAKEWEB_PORT:80"
    restart: always
EOF
    # 兼容 docker compose / docker-compose
    if command -v docker-compose >/dev/null 2>&1; then
        docker-compose up -d || true
    else
        docker compose up -d || true
    fi
}

create_systemd_service() {
    [ -f "$SINGBOX_SERVICE" ] && return
    cat > "$SINGBOX_SERVICE" <<EOF
[Unit]
Description=sing-box service
After=network.target

[Service]
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
ExecStart=/usr/local/bin/sing-box run -c $SINGBOX_CONFIG
Restart=on-failure
LimitNOFILE=infinity

[Install]
WantedBy=multi-user.target
EOF
    systemctl daemon-reload
    systemctl enable sing-box >/dev/null 2>&1 || true
}

load_existing_config() {
    if [ -f "$CERT_DIR/fullchain.pem" ]; then
        MENU_STATUS[0]="active"
        DOMAIN=$(openssl x509 -in "$CERT_DIR/fullchain.pem" -noout -subject \
            | sed -n 's/.*CN = \([^,]*\).*/\1/p' | head -n1)
    fi

    if [ -f "$SINGBOX_CONFIG" ] && command -v jq >/dev/null 2>&1 && sing-box check -c "$SINGBOX_CONFIG" >/dev/null 2>&1; then
        mapfile -t types < <(jq -r '.inbounds[].type' "$SINGBOX_CONFIG")
        mapfile -t ports < <(jq -r '.inbounds[].listen_port' "$SINGBOX_CONFIG")
        mapfile -t passwords < <(jq -r '.inbounds[].users[0].password // empty' "$SINGBOX_CONFIG")
        mapfile -t uuids < <(jq -r '.inbounds[].users[0].uuid // empty' "$SINGBOX_CONFIG")

        for i in "${!types[@]}"; do
            case "${types[$i]}" in
                trojan)    MENU_STATUS[1]="active"; TROJAN_PORT="${ports[$i]}"; TROJAN_PASS="${passwords[$i]}"; ;;
                hysteria2) MENU_STATUS[2]="active"; HYSTERIA2_PORT="${ports[$i]}"; HYSTERIA2_PASS="${passwords[$i]}"; ;;
                tuic)      MENU_STATUS[3]="active"; TUIC_PORT="${ports[$i]}"; TUIC_UUID="${uuids[$i]}"; TUIC_PASS="${passwords[$i]}"; ;;
            esac
        done
    fi
}

# ==========================
# ✅ 核心修复：续签后必定覆盖 CERT_DIR 并重启 sing-box
# ==========================
create_acme_hook() {
    local domain="$1"
    local hook="$ACME_HOME/singbox-hook.sh"

    cat > "$hook" <<EOF
#!/bin/bash
set -euo pipefail

FAKEWEB_DIR="$FAKEWEB_DIR"
CERT_DIR="$CERT_DIR"
ACME_HOME="$ACME_HOME"
DOMAIN="$domain"
SRC_DIR="\$ACME_HOME/\${DOMAIN}_ecc"

FULLCHAIN="\$SRC_DIR/fullchain.cer"
KEY="\$SRC_DIR/\${DOMAIN}.key"

# 1) 续签时可能需要占用端口：先停伪装站（不强制）
if [ -f "\$FAKEWEB_DIR/docker-compose.yml" ]; then
  if command -v docker-compose >/dev/null 2>&1; then
    (cd "\$FAKEWEB_DIR" && docker-compose down >/dev/null 2>&1) || true
  else
    (cd "\$FAKEWEB_DIR" && docker compose down >/dev/null 2>&1) || true
  fi
fi

# 2) 确保源证书存在
if [ ! -f "\$FULLCHAIN" ] || [ ! -f "\$KEY" ]; then
  echo "[HOOK] source cert not found: \$FULLCHAIN or \$KEY" >&2
  exit 1
fi

mkdir -p "\$CERT_DIR"

# 3) 覆盖 sing-box 实际使用的证书路径（关键）
cp "\$FULLCHAIN" "\$CERT_DIR/fullchain.pem"
cp "\$KEY" "\$CERT_DIR/private.pem"
chmod 600 "\$CERT_DIR/private.pem" || true

# 4) 重启 sing-box 立即加载新证书（关键）
systemctl restart sing-box

# 5) 恢复伪装站
if [ -f "\$FAKEWEB_DIR/docker-compose.yml" ]; then
  if command -v docker-compose >/dev/null 2>&1; then
    (cd "\$FAKEWEB_DIR" && docker-compose up -d >/dev/null 2>&1) || true
  else
    (cd "\$FAKEWEB_DIR" && docker compose up -d >/dev/null 2>&1) || true
  fi
fi

echo "[HOOK] cert synced to \$CERT_DIR and sing-box restarted."
EOF

    chmod +x "$hook"
    echo "$hook"
}

issue_cert() {
    [ "${MENU_STATUS[0]}" = "active" ] && { echo "证书已存在（域名: $DOMAIN）"; return; }

    read -p "请输入域名: " DOMAIN
    [[ -z "$DOMAIN" ]] && return

    mkdir -p "$CERT_DIR"

    # 签发期间可能占用端口：先停伪装站（与原逻辑一致）
    if [ -f "$FAKEWEB_DIR/docker-compose.yml" ]; then
        if command -v docker-compose >/dev/null 2>&1; then
            (cd "$FAKEWEB_DIR" && docker-compose down >/dev/null 2>&1) || true
        else
            (cd "$FAKEWEB_DIR" && docker compose down >/dev/null 2>&1) || true
        fi
    fi

    # 1) 申请证书（ECC）
    "$ACME_HOME/acme.sh" --issue --standalone -d "$DOMAIN" --keylength ec-256 --force || {
        echo "证书申请失败"
        if [ -f "$FAKEWEB_DIR/docker-compose.yml" ]; then
            if command -v docker-compose >/dev/null 2>&1; then
                (cd "$FAKEWEB_DIR" && docker-compose up -d >/dev/null 2>&1) || true
            else
                (cd "$FAKEWEB_DIR" && docker compose up -d >/dev/null 2>&1) || true
            fi
        fi
        return
    }

    # 2) 创建 HOOK（关键修复：不使用 $1/$2，固定路径复制）
    local HOOK
    HOOK=$(create_acme_hook "$DOMAIN")

    # 3) 只执行一次 install-cert：同时指定输出路径 + 注册 reloadcmd（关键修复）
    "$ACME_HOME/acme.sh" --install-cert -d "$DOMAIN" --ecc \
        --fullchain-file "$CERT_DIR/fullchain.pem" \
        --key-file "$CERT_DIR/private.pem" \
        --reloadcmd "$HOOK"

    # 4) 立刻执行一次 HOOK，确保“首次签发后”立即覆盖并重启（更稳）
    "$HOOK"

    # 自动升级 acme.sh（原逻辑保留）
    "$ACME_HOME/acme.sh" --upgrade --auto-upgrade

    # 恢复伪装站
    if [ -f "$FAKEWEB_DIR/docker-compose.yml" ]; then
        if command -v docker-compose >/dev/null 2>&1; then
            (cd "$FAKEWEB_DIR" && docker-compose up -d >/dev/null 2>&1) || true
        else
            (cd "$FAKEWEB_DIR" && docker compose up -d >/dev/null 2>&1) || true
        fi
    fi

    MENU_STATUS[0]="active"
    echo "✅ 证书已签发并安装：$DOMAIN"
    echo "✅ 后续每次续签都会自动覆盖 $CERT_DIR 并重启 sing-box（已修复）"
}

configure_singbox() {
    mkdir -p /etc/sing-box

    local need_backup=false
    if [ -f "$SINGBOX_CONFIG" ] && sing-box check -c "$SINGBOX_CONFIG" >/dev/null 2>&1; then
        need_backup=true
        cp "$SINGBOX_CONFIG" "$SINGBOX_CONFIG_BAK"
        echo "已备份当前正常配置"
    fi

    local temp_inbounds
    temp_inbounds=$(mktemp)

    # Trojan (带 fallback)
    if [ "${MENU_STATUS[1]}" = "active" ]; then
        jq -n \
            --argjson port "$TROJAN_PORT" \
            --arg pass "$TROJAN_PASS" \
            --argjson fakeport "$FAKEWEB_PORT" \
            --arg fullchain "$CERT_DIR/fullchain.pem" \
            --arg key "$CERT_DIR/private.pem" \
            '{
                type: "trojan",
                tag: "trojan-in",
                listen: "0.0.0.0",
                listen_port: $port,
                users: [{password: $pass}],
                tls: {
                    enabled: true,
                    certificate_path: $fullchain,
                    key_path: $key
                },
                fallback: {
                    server: "127.0.0.1",
                    server_port: $fakeport
                }
            }' >> "$temp_inbounds"
    fi

    # Hysteria2
    if [ "${MENU_STATUS[2]}" = "active" ]; then
        jq -n \
            --argjson port "$HYSTERIA2_PORT" \
            --arg pass "$HYSTERIA2_PASS" \
            --argjson bw "$HYSTERIA_BANDWIDTH" \
            --arg fullchain "$CERT_DIR/fullchain.pem" \
            --arg key "$CERT_DIR/private.pem" \
            '{
                type: "hysteria2",
                tag: "hysteria2-in",
                listen: "0.0.0.0",
                listen_port: $port,
                up_mbps: $bw,
                down_mbps: $bw,
                users: [{password: $pass}],
                tls: {
                    enabled: true,
                    certificate_path: $fullchain,
                    key_path: $key
                }
            }' >> "$temp_inbounds"
    fi

    # Tuic
    if [ "${MENU_STATUS[3]}" = "active" ]; then
        jq -n \
            --argjson port "$TUIC_PORT" \
            --arg uuid "$TUIC_UUID" \
            --arg pass "$TUIC_PASS" \
            --arg fullchain "$CERT_DIR/fullchain.pem" \
            --arg key "$CERT_DIR/private.pem" \
            '{
                type: "tuic",
                tag: "tuic-in",
                listen: "0.0.0.0",
                listen_port: $port,
                users: [{uuid: $uuid, password: $pass}],
                congestion_control: "cubic",
                tls: {
                    enabled: true,
                    certificate_path: $fullchain,
                    key_path: $key
                }
            }' >> "$temp_inbounds"
    fi

    # 用 jq 组装最终配置
    if [ -s "$temp_inbounds" ]; then
        jq -s '{
            log: {level: "info"},
            inbounds: .,
            outbounds: [{type: "direct", tag: "direct"}]
        }' "$temp_inbounds" > "$SINGBOX_CONFIG"
    else
        jq -n '{
            log: {level: "info"},
            inbounds: [],
            outbounds: [{type: "direct", tag: "direct"}]
        }' > "$SINGBOX_CONFIG"
    fi

    rm -f "$temp_inbounds"

    # 校验
    echo "正在校验配置..."
    if sing-box check -c "$SINGBOX_CONFIG" >/dev/null 2>&1; then
        echo "配置校验成功！"
        if $need_backup; then
            rm -f "$SINGBOX_CONFIG_BAK"
        fi
    else
        echo "配置异常！"
        if $need_backup; then
            echo "回滚到上一版本..."
            cp "$SINGBOX_CONFIG_BAK" "$SINGBOX_CONFIG"
            rm -f "$SINGBOX_CONFIG_BAK"
            echo "已恢复正常配置"
        else
            echo "首次配置失败，请检查日志或手动编辑 $SINGBOX_CONFIG"
        fi
        return 1
    fi

    return 0
}

restart_singbox() {
    systemctl restart sing-box
    if [ $? -eq 0 ]; then
        echo "sing-box 服务启动成功"
    else
        echo "sing-box 服务启动失败，查看日志："
        journalctl -u sing-box.service -n 30 --no-pager
    fi
}

print_all_nodes_and_nodelist() {
    echo -e "\n\033[1;32m========== 所有节点连接信息 ==========\033[0m"
    [ "${MENU_STATUS[1]}" = "active" ] && echo "Trojan: trojan://$TROJAN_PASS@$DOMAIN:$TROJAN_PORT?#Trojan"
    [ "${MENU_STATUS[2]}" = "active" ] && echo "Hysteria2: hysteria2://$HYSTERIA2_PASS@$DOMAIN:$HYSTERIA2_PORT/?sni=$DOMAIN#Hysteria2"
    [ "${MENU_STATUS[3]}" = "active" ] && echo "Tuic: tuic://$TUIC_UUID:$TUIC_PASS@$DOMAIN:$TUIC_PORT/?sni=$DOMAIN&congestion_control=cubic#Tuic"
    echo -e "\033[1;32m======================================\033[0m\n"

    local nodelist=""
    [ "${MENU_STATUS[1]}" = "active" ] && nodelist+="trojan://$TROJAN_PASS@$DOMAIN:$TROJAN_PORT?#Trojan\n"
    [ "${MENU_STATUS[2]}" = "active" ] && nodelist+="hysteria2://$HYSTERIA2_PASS@$DOMAIN:$HYSTERIA2_PORT/?sni=$DOMAIN#Hysteria2\n"
    [ "${MENU_STATUS[3]}" = "active" ] && nodelist+="tuic://$TUIC_UUID:$TUIC_PASS@$DOMAIN:$TUIC_PORT/?sni=$DOMAIN&congestion_control=cubic#Tuic\n"

    if [[ -n "$nodelist" ]]; then
        local base64
        base64=$(echo -e "$nodelist" | base64 -w 0 2>/dev/null || echo -e "$nodelist" | base64 | tr -d '\n')
        echo -e "\033[1;33m========== NodeList 订阅（Base64）==========\033[0m"
        echo "$base64"
        echo -e "\033[1;33m复制上方 Base64 保存为文件或用于订阅转换\033[0m\n"
    fi
}

show_menu() {
    while true; do
        clear
        echo "========== Sing-box 节点管理 =========="
        echo "1. 创建/查看域名证书 [${MENU_STATUS[0]}] ${DOMAIN:+域名:$DOMAIN}"
        echo "2. Trojan 节点 [${MENU_STATUS[1]}] ${TROJAN_PORT:+端口:$TROJAN_PORT} ${MENU_STATUS[1]:+（已启用 fallback 最强伪装）}"
        echo "3. Hysteria2 节点 [${MENU_STATUS[2]}] ${HYSTERIA2_PORT:+端口:$HYSTERIA2_PORT}"
        echo "4. Tuic 节点 [${MENU_STATUS[3]}] ${TUIC_PORT:+端口:$TUIC_PORT}"
        echo "5. 查看所有节点信息和订阅"
        echo "0. 退出"
        echo "=================================="
        read -p "选择: " c
        case $c in
            1) issue_cert; create_systemd_service ;;
            2|3|4)
                [ "${MENU_STATUS[0]}" != "active" ] && { echo "请先创建证书"; read -n1 -s; continue; }
                if [[ $c == 2 && "${MENU_STATUS[1]}" == "active" ]] || [[ $c == 3 && "${MENU_STATUS[2]}" == "active" ]] || [[ $c == 4 && "${MENU_STATUS[3]}" == "active" ]]; then
                    echo "该节点已启用"
                    read -p "是否重新配置？(y/N): " reconf
                    [[ ! "$reconf" =~ ^[Yy]$ ]] && continue
                fi

                if [[ $c == 2 ]]; then
                    read -p "Trojan 端口 (默认443): " p; TROJAN_PORT=${p:-443}
                    while ! check_port "$TROJAN_PORT"; do read -p "重新输入: " TROJAN_PORT; done
                    TROJAN_PASS=$(generate_password)
                    echo "新密码: $TROJAN_PASS"
                    MENU_STATUS[1]="active"
                elif [[ $c == 3 ]]; then
                    read -p "Hysteria2 端口: " HYSTERIA2_PORT
                    while ! check_port "$HYSTERIA2_PORT" || [ -z "$HYSTERIA2_PORT" ]; do read -p "重新输入: " HYSTERIA2_PORT; done
                    HYSTERIA2_PASS=$(generate_password)
                    echo "新密码: $HYSTERIA2_PASS"
                    MENU_STATUS[2]="active"
                else
                    read -p "Tuic 端口: " TUIC_PORT
                    while ! check_port "$TUIC_PORT" || [ -z "$TUIC_PORT" ]; do read -p "重新输入: " TUIC_PORT; done
                    TUIC_UUID=$(generate_uuid)
                    TUIC_PASS=$(generate_password)
                    echo "UUID: $TUIC_UUID"
                    echo "密码: $TUIC_PASS"
                    MENU_STATUS[3]="active"
                fi

                if configure_singbox; then
                    restart_singbox
                    print_all_nodes_and_nodelist
                else
                    echo "配置失败，请检查日志或手动编辑 $SINGBOX_CONFIG"
                fi
                ;;
            5) print_all_nodes_and_nodelist ;;
            0) exit 0 ;;
            *) echo "无效选项"; read -n1 -s ;;
        esac
        read -p "按回车继续..."
    done
}

# 主流程
install_dependencies
check_singbox
check_acme
deploy_fakeweb
create_systemd_service
load_existing_config
show_menu
